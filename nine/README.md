# Clojure

## Переменные
Чтобы определить переменную нужна специальная форма `def`. Форма, потому что первый аргумент нельзя вычислить.
Пример:
```
(def x 10)
```
Однако переменные в Clojure менять нельзя.

## Преобразования
```
(<type> <expression>)
```

## Поверка на тип
```
(<type>? <expression>) // -> boolean
```

## Вывод
```
(println [аргументы])
```

## Функции
```
(defn <func-name>
    [arguements]
    (<body>)
)
```

### Лямбда-функции
```
(#(+ %1 %2) 10 20) // -> 30
```

Если у функции один аргумент, то нумеровать их не надо: `(#(+ %) 10)`

### Рекурсивные функции
`recur` - вызывает рекурсивно функцию, в которой исполняется **без использования стека** 
Это достигается за счёт того, что мы гарантируем не использовать переменные (иначе ошибка) и результат, переданные ей в аргументы. Следовательно, функция выполняется напрямую заново.

### Функции с различным числом аргументов
```
(defn <name> 
    ([arguements] (body))
    ([arguements1] (body2))
    ...
)
```

### Пред/пост-условия
```
(defn <func-name> 
    {
        :pre [<boolean expression>]
        :post [<boolean expression>]
    } 
    [arguements]
    (<body>)
)
```
Результат функции обозначается через `%`

## Ветвления
```
(defn fib [n] (
                cond
                (<= n 1) 1
                :else (+ (fib (- n 1)) (fib (- n 2)))
                )
  )
```
## Вычисления без переполнения
Эту проблему можно решить следующим образом:
* давать на вход числа ч суффиксом `N`
* `(<operator>')`. Например:
  * `(+' 2 3)` 
  * `(-' 100 20)` 


## Структуры данных 
```
(list 10 20 30) // - список из 3 элементов
(def x (list 10 20 30)
```
* `list`
  * `(count x)` -> 3
  * `(nth x 2)` -> 30
  * это **БИНАРНЫЕ ДЕРЕВЬЯ** (нихрена не понял как они хранятся, но ок)
* `vector` равносильно `[..]`
  * быстрее работает добавление

Однако `conj`, как вы наверное подумали, добавляет элементы в структуру. Ничего подобного. Он возвращает ту же структуру с добалвенным элементом. То есть исходная сущность остаётся неизменной (_посмотрите в самое начало про переменные_).

> Интересно что `conj` операция, которая добавляет элементы в
> структуры ведёт себя по-разному с ними. В `list` она добавляет элементы вперед, а в `vector`
> назад.
### Изменение элемента по индексу
`assoc` позволяет менять элементы по индексу.
> Для `list` не работает. Проверял.
```
(assoc <struct> <index> <value>)
```
И он тоже не меняет исходную структуру, а возвращает её изменённую копию.
> Кстати `assoc` можно так же использовать для добавления элементов. Главное чтобы указанный индекс различался с границами не более чем на 1.
```
(def v (vector 1 2 3))
(assoc v -1 5) // 0 -> [5 1 2 3]
(assoc v 3 7) // 0 -> [1 2 3 7]
```
___
Посмотреть что такое:

`map`, `nth`, `dec`, 
`range`, `memoize`, `let[fn]`,
`first`, `assoc`, `vector`, `list`,
`apply`, `juxt`.

Очень странные вещи
`identity`, `constantly`, `partial`
предикаты
___
Документация
* [Clojure Reference](https://clojure.org/reference/documentation)
* [Clojure Cheat Sheet](https://clojure.org/api/cheatsheet)