# Clojure

## Переменные
Чтобы определить переменную нужна специальная форма `def`. Форма, потому что первый аргумент нельзя вычислить.
Пример:
```
(def x 10)
```
Однако переменные в Clojure менять нельзя.

## Преобразования
```
(<type> <expression>)
```

## Поверка на тип
```
(<type>? <expression>) // -> boolean
```

## Вывод
```
(println [аргументы])
```

## Функции
```
(defn <func-name>
    [arguements]
    (<body>)
)
```

### Лямбда-функции
```
(#(+ %1 %2) 10 20) // -> 30
```

Если у функции один аргумент то нумеровать их не надо: `(#(+ %) 10)`

### Рекурсивные функции
`recur` - вызывает рекурсивно функцию, в которой исполняется **без использовывания стека** 
Это достигается за счёт того, что мы гарантируем не использовать переменные (иначе ошибка) и результат, переданные ей в аргументы. Следовательно, функция выполняется напрямую заново.

### Функции с различным числом аргументов
```
(defn <name> 
    ([arguements] (body))
    ([arguements1] (body2))
    ...
)
```

### Пред/пост-условия
```
(defn <func-name> 
    {
        :pre [<boolean expression>]
        :post [<boolean expression>]
    } 
    [arguements]
    (<body>)
)
```
Результат функции обозначается через `%`

## Ветвления
```
(defn fib [n] (
                cond
                (<= n 1) 1
                :else (+ (fib (- n 1)) (fib (- n 2)))
                )
  )
```
## Вычисления без переполнения
Эту проблему можно решить следующим образом:
* давать на вход числа ч суффиксом `N`
* `(<operator>')`. Например:
  * `(+' 2 3)` 
  * `(-' 100 20)` 


## Структуры данных 
```
(list 10 20 30) // - список из 3 элементов
(def x (list 10 20 30)
```
* `list`
  * `(count x)` -> 3
  * `(nth x 2)` -> 30
  * это **БИНАРНЫЕ ДЕРЕВЬЯ** (нихрена не понял как они хранятся, но ок)
___
Посмотреть что такое 
`map`, `nth`, `dec`, 
`range`, `memoize`, `let[fn]`,
`first`,
предикаты
___