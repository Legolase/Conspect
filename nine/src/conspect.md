# Clojure
## Переменные
Чтобы определить переменную нужна специальная форма `def`. Форма, потому что первый аргумент нельзя вычислить.
Пример:
```
(def x 10)
```
Однако переменные в Clojure менять нельзя.

## Преобразования
```
(<type> <expression>)
```

## Поверка на тип
```
(<type>? <expression>) // -> boolean
```

## Вывод
```
(println [аргументы])
```

## Функции
```
(defn <func-name>
    [arguements]
    (<body>)
)
```

### Лямбда-функции
```
(#(+ %1 %2) 10 20) // -> 30
```

Если у функции один аргумент то нумеровать их не надо: `(#(+ %) 10)`

### Рекрсивные функции
`recur` - вызывает рекурсивно функцию, в которой исполняется **без использовывания стека** 
Это достигается за счёт того, что мы гарантируем не использовать переменные (иначе ошибка), переданные ей в аргументы. Следовательно, функция выполняется напрямую заново.

### Функции с различным числом аргументов
```
(defn <name> 
    ([arguements] (body))
    ([arguements1] (body2))
    ...
)
```

### Пред/пост-условия
```
(defn <func-name> 
    {
        :pre [<boolean expression>]
        :post [<boolean expression>]
    } 
    [arguements]
    (<body>)
)
```

## Ветвления
```
(defn fib [n] (
                cond
                (<= n 1) 1
                :else (+ (fib (- n 1)) (fib (- n 2)))
                )
  )
```
## Вычисления без переполнения
Эту проблему можно решить следующим образом:
* давать на вход числа ч суффиксом `N`
* `(<operator>')`. Например:
  * `(+' 2 3)` 
  * `(-' 100 20)` 

___
Посмотреть что такое `map`, `nth`, `dec`, `range`, `memoize`, `let[fn]`, предикаты
___